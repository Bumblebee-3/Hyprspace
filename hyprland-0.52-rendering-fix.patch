diff --git a/src/Input.cpp b/src/Input.cpp
index 5cd382c..00c7cdc 100644
--- a/src/Input.cpp
+++ b/src/Input.cpp
@@ -89,12 +89,16 @@ bool CHyprspaceWidget::axisEvent(double delta, Vector2D coords) {
     else {
         if (delta < 0) {
             SWorkspaceIDName wsIDName = getWorkspaceIDNameFromString("r-1");
-            if (g_pCompositor->getWorkspaceByID(wsIDName.id) == nullptr) g_pCompositor->createNewWorkspace(wsIDName.id, ownerID);
+            if (g_pCompositor->getWorkspaceByID(wsIDName.id) == nullptr) {
+                [[maybe_unused]] auto ws = g_pCompositor->createNewWorkspace(wsIDName.id, ownerID);
+            }
             getOwner()->changeWorkspace(wsIDName.id);
         }
         else {
             SWorkspaceIDName wsIDName = getWorkspaceIDNameFromString("r+1");
-            if (g_pCompositor->getWorkspaceByID(wsIDName.id) == nullptr) g_pCompositor->createNewWorkspace(wsIDName.id, ownerID);
+            if (g_pCompositor->getWorkspaceByID(wsIDName.id) == nullptr) {
+                [[maybe_unused]] auto ws = g_pCompositor->createNewWorkspace(wsIDName.id, ownerID);
+            }
             getOwner()->changeWorkspace(wsIDName.id);
         }
     }
diff --git a/src/Layout.cpp b/src/Layout.cpp
index 54b7bf6..d3524a7 100644
--- a/src/Layout.cpp
+++ b/src/Layout.cpp
@@ -24,16 +24,21 @@ void CHyprspaceWidget::updateLayout() {
     // Geneva Convention violation type hack but idc atm
     if (active) {
         const auto oActiveWorkspace = pMonitor->m_activeWorkspace;
+        
+        // Safety check: ensure active workspace is valid
+        if (!oActiveWorkspace) return;
 
         for (auto& ws : g_pCompositor->getWorkspaces()) { // HACK: recalculate other workspaces without reserved area
-            if (ws->m_monitor->m_id == ownerID && ws->m_id != oActiveWorkspace->m_id) {
+            if (ws && ws->m_monitor && ws->m_monitor->m_id == ownerID && ws->m_id != oActiveWorkspace->m_id) {
                 pMonitor->m_activeWorkspace = ws.lock();
                 const auto curRules = std::to_string(pMonitor->activeWorkspaceID()) + ", gapsin:" + PGAPSIN->toString() + ", gapsout:" + PGAPSOUT->toString();
                 if (Config::overrideGaps) g_pConfigManager->handleWorkspaceRules("", curRules);
                 g_pLayoutManager->getCurrentLayout()->recalculateMonitor(ownerID);
             }
         }
-        pMonitor->m_activeWorkspace = oActiveWorkspace;
+        // Restore original active workspace safely
+        if (oActiveWorkspace)
+            pMonitor->m_activeWorkspace = oActiveWorkspace;
         if (!Config::onBottom)
             pMonitor->m_reservedTopLeft.y = currentHeight;
         else
@@ -45,7 +50,7 @@ void CHyprspaceWidget::updateLayout() {
     }
     else {
         for (auto& ws : g_pCompositor->getWorkspaces()) {
-            if (ws->m_monitor->m_id == ownerID) {
+            if (ws && ws->m_monitor && ws->m_monitor->m_id == ownerID) {
                 const auto curRules = std::to_string(ws->m_id) + ", gapsin:" + PGAPSIN->toString() + ", gapsout:" + PGAPSOUT->toString();
                 if (Config::overrideGaps) g_pConfigManager->handleWorkspaceRules("", curRules);
                 g_pLayoutManager->getCurrentLayout()->recalculateMonitor(ownerID);
diff --git a/src/Overview.cpp b/src/Overview.cpp
index 2e27e21..6e51530 100644
--- a/src/Overview.cpp
+++ b/src/Overview.cpp
@@ -51,12 +51,16 @@ void CHyprspaceWidget::show() {
     // FIXME: ensure input is disabled for hidden layers
     if (oLayerAlpha.empty() && Config::hideRealLayers) {
         for (auto& ls : owner->m_layerSurfaceLayers[2]) {
+            // Validate layer surface before modifying (Hyprland 0.52 safety)
+            if (!ls || ls->m_readyToDelete || !ls->m_mapped) continue;
             //ls->startAnimation(false);
             oLayerAlpha.emplace_back(std::make_tuple(ls.lock(), ls->m_alpha->goal()));
             *ls->m_alpha = 0.f;
             ls->m_fadingOut = true;
         }
         for (auto& ls : owner->m_layerSurfaceLayers[3]) {
+            // Validate layer surface before modifying (Hyprland 0.52 safety)
+            if (!ls || ls->m_readyToDelete || !ls->m_mapped) continue;
             //ls->startAnimation(false);
             oLayerAlpha.emplace_back(std::make_tuple(ls.lock(), ls->m_alpha->goal()));
             *ls->m_alpha = 0.f;
@@ -81,10 +85,16 @@ void CHyprspaceWidget::hide() {
     auto owner = getOwner();
     if (!owner) return;
 
-    // restore layer state
+    active = false;
+
+    // restore layer state - check validity before accessing
     for (auto& ls : owner->m_layerSurfaceLayers[2]) {
-        if (!ls->m_readyToDelete && ls->m_mapped && ls->m_fadingOut) {
-            auto oAlpha = std::find_if(oLayerAlpha.begin(), oLayerAlpha.end(), [&] (const auto& tuple) {return std::get<0>(tuple) == ls;});
+        // Additional validation for Hyprland 0.52
+        if (!ls || (!ls->m_readyToDelete && ls->m_mapped && ls->m_fadingOut)) {
+            auto oAlpha = std::find_if(oLayerAlpha.begin(), oLayerAlpha.end(), [&] (const auto& tuple) {
+                auto stored = std::get<0>(tuple);
+                return stored && stored == ls;
+            });
             if (oAlpha != oLayerAlpha.end()) {
                 ls->m_fadingOut = false;
                 *ls->m_alpha = std::get<1>(*oAlpha);
@@ -93,8 +103,12 @@ void CHyprspaceWidget::hide() {
         }
     }
     for (auto& ls : owner->m_layerSurfaceLayers[3]) {
-        if (!ls->m_readyToDelete && ls->m_mapped && ls->m_fadingOut) {
-            auto oAlpha = std::find_if(oLayerAlpha.begin(), oLayerAlpha.end(), [&] (const auto& tuple) {return std::get<0>(tuple) == ls;});
+        // Additional validation for Hyprland 0.52
+        if (!ls || (!ls->m_readyToDelete && ls->m_mapped && ls->m_fadingOut)) {
+            auto oAlpha = std::find_if(oLayerAlpha.begin(), oLayerAlpha.end(), [&] (const auto& tuple) {
+                auto stored = std::get<0>(tuple);
+                return stored && stored == ls;
+            });
             if (oAlpha != oLayerAlpha.end()) {
                 ls->m_fadingOut = false;
                 *ls->m_alpha = std::get<1>(*oAlpha);
@@ -104,17 +118,17 @@ void CHyprspaceWidget::hide() {
     }
     oLayerAlpha.clear();
 
-    // restore fullscreen state
+    // restore fullscreen state - check window validity
     for (auto& fs : prevFullscreen) {
         const auto w = g_pCompositor->getWindowFromHandle(std::get<0>(fs));
-        const auto oFullscreenMode = std::get<1>(fs);
-        g_pCompositor->setWindowFullscreenState(w, SFullscreenState(oFullscreenMode)); 
-        if (oFullscreenMode == FSMODE_FULLSCREEN) w->m_wantsInitialFullscreen = false;
+        if (w && w->m_workspace && w->m_workspace->m_monitor) {
+            const auto oFullscreenMode = std::get<1>(fs);
+            g_pCompositor->setWindowFullscreenState(w, SFullscreenState(oFullscreenMode)); 
+            if (oFullscreenMode == FSMODE_FULLSCREEN) w->m_wantsInitialFullscreen = false;
+        }
     }
     prevFullscreen.clear();
 
-    active = false;
-
     // panel offset should be handled by swipe event when swiping
     if (!swiping) {
         *curYOffset = (Config::panelHeight + Config::reservedArea) * owner->m_scale;
diff --git a/src/Render.cpp b/src/Render.cpp
index 3d364e0..4a51c88 100644
--- a/src/Render.cpp
+++ b/src/Render.cpp
@@ -64,59 +64,37 @@ void renderBorder(CBox box, CGradientValueData gradient, int size) {
     g_pHyprRenderer->m_renderPass.add(makeUnique<CBorderPassElement>(data));
 }
 
-void renderWindowStub(PHLWINDOW pWindow, PHLMONITOR pMonitor, PHLWORKSPACE pWorkspaceOverride, CBox rectOverride, timespec* time) {
-    if (!pWindow || !pMonitor || !pWorkspaceOverride || !time) return;
-
-    SRenderModifData renderModif;
+void renderWindowStub(PHLWINDOW pWindow, PHLMONITOR pMonitor, CBox rectOverride, timespec* time) {
+    // Overview preview without mutating window state (prevents crashes / flicker in Hyprland 0.52)
+    if (!pWindow || !pMonitor || !time) return;
 
-    const auto oWorkspace = pWindow->m_workspace;
-    const auto oFullscreen = pWindow->m_fullscreenState;
+    // Enhanced validation for Hyprland 0.52
+    if (!pWindow->m_isMapped || pWindow->isHidden() || !pWindow->m_workspace) return;
+    
     const auto oRealPosition = pWindow->m_realPosition->value();
     const auto oSize = pWindow->m_realSize->value();
-    const auto oUseNearestNeighbor = pWindow->m_windowData.nearestNeighbor;
-    const auto oPinned = pWindow->m_pinned;
-    const auto oDraggedWindow = g_pInputManager->m_currentlyDraggedWindow;
-    const auto oDragMode = g_pInputManager->m_dragMode;
-    const auto oRenderModifEnable = g_pHyprOpenGL->m_renderData.renderModif.enabled;
-    const auto oFloating = pWindow->m_isFloating;
+    if (oSize.x <= 0 || oSize.y <= 0) return;
+
+    // Check if window has valid surface (m_wlSurface is a SP, check if it exists and has valid resource)
+    if (!pWindow->m_wlSurface || !pWindow->m_wlSurface->exists()) return;
 
     const float curScaling = rectOverride.w / (oSize.x * pMonitor->m_scale);
 
-    // using renderModif struct to override the position and scale of windows
-    // this will be replaced by matrix transformations in hyprland
+    SRenderModifData renderModif;
     renderModif.modifs.push_back({SRenderModifData::eRenderModifType::RMOD_TYPE_TRANSLATE, (pMonitor->m_position * pMonitor->m_scale) + (rectOverride.pos() / curScaling) - (oRealPosition * pMonitor->m_scale)});
     renderModif.modifs.push_back({SRenderModifData::eRenderModifType::RMOD_TYPE_SCALE, curScaling});
     renderModif.enabled = true;
-    pWindow->m_workspace = pWorkspaceOverride;
-    pWindow->m_fullscreenState = SFullscreenState{FSMODE_NONE};
-    pWindow->m_windowData.nearestNeighbor = false;
-    pWindow->m_isFloating = false;
-    pWindow->m_pinned = true;
-    pWindow->m_windowData.rounding = CWindowOverridableVar<Hyprlang::INT>(pWindow->rounding() * curScaling * pMonitor->m_scale, eOverridePriority::PRIORITY_SET_PROP);
-    g_pInputManager->m_currentlyDraggedWindow = pWindow; // override these and force INTERACTIVERESIZEINPROGRESS = true to trick the renderer
-    g_pInputManager->m_dragMode = MBIND_RESIZE;
 
     g_pHyprRenderer->m_renderPass.add(makeUnique<CRendererHintsPassElement>(CRendererHintsPassElement::SData{renderModif}));
-    // remove modif as it goes out of scope (wtf is this blackmagic i need to relearn c++)
     Hyprutils::Utils::CScopeGuard x([] {
         g_pHyprRenderer->m_renderPass.add(makeUnique<CRendererHintsPassElement>(CRendererHintsPassElement::SData{SRenderModifData{}}));
-        });
-
-    g_pHyprRenderer->damageWindow(pWindow);
-
-    (*(tRenderWindow)pRenderWindow)(g_pHyprRenderer.get(), pWindow, pMonitor, time, true, RENDER_PASS_ALL, false, false);
+    });
 
-    // restore values for normal window render
-    pWindow->m_workspace = oWorkspace;
-    pWindow->m_fullscreenState = oFullscreen;
-    pWindow->m_windowData.nearestNeighbor = oUseNearestNeighbor;
-    pWindow->m_isFloating = oFloating;
-    pWindow->m_pinned = oPinned;
-    pWindow->m_windowData.rounding.unset(eOverridePriority::PRIORITY_SET_PROP);
-    g_pInputManager->m_currentlyDraggedWindow = oDraggedWindow;
-    g_pInputManager->m_dragMode = oDragMode;
+    // CRITICAL FIX: Use RENDER_PASS_MAIN only for workspace previews
+    // RENDER_PASS_ALL causes texture/buffer conflicts when rendering windows from inactive workspaces
+    // The transform modifiers handle positioning - we just need the window's current texture
+    (*(tRenderWindow)pRenderWindow)(g_pHyprRenderer.get(), pWindow, pMonitor, time, false, RENDER_PASS_MAIN, false, false);
 }
-
 // Special rendering function for focused windows that minimizes state changes
 void renderFocusedWindowStub(PHLWINDOW pWindow, PHLMONITOR pMonitor, PHLWORKSPACE pWorkspaceOverride, CBox rectOverride, timespec* time) {
     if (!pWindow || !pMonitor || !pWorkspaceOverride || !time) return;
@@ -125,12 +103,10 @@ void renderFocusedWindowStub(PHLWINDOW pWindow, PHLMONITOR pMonitor, PHLWORKSPAC
     const auto oWorkspace = pWindow->m_workspace;
     const auto oFullscreen = pWindow->m_fullscreenState;
     const auto oPinned = pWindow->m_pinned;
-    const auto oUseNearestNeighbor = pWindow->m_windowData.nearestNeighbor;
 
     // Apply minimal state changes for preview rendering
     pWindow->m_workspace = pWorkspaceOverride;
     pWindow->m_fullscreenState = SFullscreenState{FSMODE_NONE};
-    pWindow->m_windowData.nearestNeighbor = false;
     pWindow->m_pinned = true;
 
     // Use render modification for position and scale without touching window properties
@@ -157,10 +133,8 @@ void renderFocusedWindowStub(PHLWINDOW pWindow, PHLMONITOR pMonitor, PHLWORKSPAC
     // Restore only the essential state
     pWindow->m_workspace = oWorkspace;
     pWindow->m_fullscreenState = oFullscreen;
-    pWindow->m_windowData.nearestNeighbor = oUseNearestNeighbor;
     pWindow->m_pinned = oPinned;
 }
-
 void renderLayerStub(PHLLS pLayer, PHLMONITOR pMonitor, CBox rectOverride, timespec* time) {
     if (!pLayer || !pMonitor || !time) return;
 
@@ -168,8 +142,10 @@ void renderLayerStub(PHLLS pLayer, PHLMONITOR pMonitor, CBox rectOverride, times
 
     Vector2D oRealPosition = pLayer->m_realPosition->value();
     Vector2D oSize = pLayer->m_realSize->value();
+    
+    if (oSize.x <= 0 || oSize.y <= 0) return;
+    
     float oAlpha = pLayer->m_alpha->value(); // set to 1 to show hidden top layer
-    const auto oRenderModifEnable = g_pHyprOpenGL->m_renderData.renderModif.enabled;
     const auto oFadingOut = pLayer->m_fadingOut;
 
     const float curScaling = rectOverride.w / (oSize.x);
@@ -232,7 +208,7 @@ void CHyprspaceWidget::draw() {
     // Panel Border
     if (Config::panelBorderWidth > 0) {
         // Border box
-        CBox borderBox = {widgetBox.x, owner->m_position.y + (Config::onBottom * owner->m_transformedSize.y) + (Config::panelHeight + Config::reservedArea - curYOffset->value() * owner->m_scale) * bottomInvert, owner->m_transformedSize.x, Config::panelBorderWidth};
+        CBox borderBox = {widgetBox.x, owner->m_position.y + (Config::onBottom * owner->m_transformedSize.y) + (Config::panelHeight + Config::reservedArea - curYOffset->value() * owner->m_scale) * bottomInvert, owner->m_transformedSize.x, static_cast<double>(Config::panelBorderWidth)};
         borderBox.y -= owner->m_position.y;
 
         renderRect(borderBox, Config::panelBorderColor);
@@ -249,6 +225,43 @@ void CHyprspaceWidget::draw() {
     // unoptimized atm but hey its working
     CFakeDamageElement fakeDamage = CFakeDamageElement(CBox({0, 0}, owner->m_transformedSize));
     g_pHyprRenderer->m_renderPass.add(makeUnique<CFakeDamageElement>(fakeDamage));
+}
+
+
+void renderWindowStub(PHLWINDOW pWindow, PHLMONITOR pMonitor, CBox rectOverride, timespec* time) {
+    // Overview preview without mutating window state (prevents crashes / flicker in Hyprland 0.52)
+    if (!pWindow || !pMonitor || !time) return;
+
+    // Enhanced validation for Hyprland 0.52
+    if (!pWindow->m_isMapped || pWindow->isHidden() || !pWindow->m_workspace) return;
+    
+    const auto oRealPosition = pWindow->m_realPosition->value();
+    const auto oSize = pWindow->m_realSize->value();
+    if (oSize.x <= 0 || oSize.y <= 0) return;
+
+    // Check if window has valid surface (m_wlSurface is a SP, check if it exists and has valid resource)
+    if (!pWindow->m_wlSurface || !pWindow->m_wlSurface->exists()) return;
+
+    const float curScaling = rectOverride.w / (oSize.x * pMonitor->m_scale);
+
+    SRenderModifData renderModif;
+    renderModif.modifs.push_back({SRenderModifData::eRenderModifType::RMOD_TYPE_TRANSLATE, (pMonitor->m_position * pMonitor->m_scale) + (rectOverride.pos() / curScaling) - (oRealPosition * pMonitor->m_scale)});
+    renderModif.modifs.push_back({SRenderModifData::eRenderModifType::RMOD_TYPE_SCALE, curScaling});
+    renderModif.enabled = true;
+
+    g_pHyprRenderer->m_renderPass.add(makeUnique<CRendererHintsPassElement>(CRendererHintsPassElement::SData{renderModif}));
+    Hyprutils::Utils::CScopeGuard x([] {
+        g_pHyprRenderer->m_renderPass.add(makeUnique<CRendererHintsPassElement>(CRendererHintsPassElement::SData{SRenderModifData{}}));
+    });
+
+    // CRITICAL FIX for Hyprland 0.52: Use RENDER_PASS_MAIN (not ALL)
+    // Windows from inactive workspaces need to render with their own texture buffers
+    // RENDER_PASS_ALL was causing texture conflicts showing wallpaper/black screens
+    // The transform modifiers handle all positioning - we just need the window's current texture
+    (*(tRenderWindow)pRenderWindow)(g_pHyprRenderer.get(), pWindow, pMonitor, time, false, RENDER_PASS_MAIN, false, false);
+}
+// Special rendering function for focused windows that minimizes state changes
+void renderFocusedWindowStub(PHLWINDOW pWindow, PHLMONITOR pMonitor, PHLWORKSPACE pWorkspaceOverride, CBox rectOverride, timespec* time) {
 
     // the list of workspaces to show
     std::vector<int> workspaces;
@@ -379,6 +392,8 @@ void CHyprspaceWidget::draw() {
             // draw tiled windows
             for (auto& w : g_pCompositor->m_windows) {
                 if (!w) continue;
+                // Skip invalid windows or windows without proper state
+                if (!w->m_isMapped || w->isHidden()) continue;
                 if (w->m_workspace == ws && !w->m_isFloating) {
                     double wX = curWorkspaceRectOffsetX + ((w->m_realPosition->value().x - owner->m_position.x) * monitorSizeScaleFactor * owner->m_scale);
                     double wY = curWorkspaceRectOffsetY + ((w->m_realPosition->value().y - owner->m_position.y) * monitorSizeScaleFactor * owner->m_scale);
@@ -387,38 +402,16 @@ void CHyprspaceWidget::draw() {
                     if (!(wW > 0 && wH > 0)) continue;
                     CBox curWindowBox = {wX, wY, wW, wH};
                     g_pHyprOpenGL->m_renderData.clipBox = curWorkspaceBox;
-
-                    // For focused windows, choose rendering method based on config
-                    if (w == g_pCompositor->m_lastWindow.lock()) {
-                        if (Config::showFocusedWindowContent) {
-                            // Try to show actual window content (experimental)
-                            renderFocusedWindowStub(w, owner, owner->m_activeWorkspace, curWindowBox, &time);
-                        } else if (Config::enableFocusedWindowPlaceholder) {
-                            // Use placeholder rendering (safe default)
-                            CHyprColor placeholderColor = Config::focusedWindowPlaceholderColor;
-                            CHyprColor borderColor = Config::focusedWindowPlaceholderBorderColor;
-
-                            if (!Config::disableBlur) {
-                                renderRectWithBlur(curWindowBox, placeholderColor);
-                            } else {
-                                renderRect(curWindowBox, placeholderColor);
-                            }
-
-                            // Add a border to indicate it's the focused window
-                            if (Config::workspaceBorderSize > 0) {
-                                renderBorder(curWindowBox, CGradientValueData(borderColor), Config::workspaceBorderSize);
-                            }
-                        }
-                    } else {
-                        //g_pHyprOpenGL->renderRectWithBlur(&curWindowBox, CHyprColor(0, 0, 0, 0));
-                        renderWindowStub(w, owner, owner->m_activeWorkspace, curWindowBox, &time);
-                    }
+                    //g_pHyprOpenGL->renderRectWithBlur(&curWindowBox, CHyprColor(0, 0, 0, 0));
+                    renderWindowStub(w, owner, curWindowBox, &time);
                     g_pHyprOpenGL->m_renderData.clipBox = CBox();
                 }
             }
             // draw floating windows
             for (auto& w : g_pCompositor->m_windows) {
                 if (!w) continue;
+                // Skip invalid windows or windows without proper state
+                if (!w->m_isMapped || w->isHidden()) continue;
                 if (w->m_workspace == ws && w->m_isFloating && ws->getLastFocusedWindow() != w) {
                     double wX = curWorkspaceRectOffsetX + ((w->m_realPosition->value().x - owner->m_position.x) * monitorSizeScaleFactor * owner->m_scale);
                     double wY = curWorkspaceRectOffsetY + ((w->m_realPosition->value().y - owner->m_position.y) * monitorSizeScaleFactor * owner->m_scale);
@@ -427,32 +420,8 @@ void CHyprspaceWidget::draw() {
                     if (!(wW > 0 && wH > 0)) continue;
                     CBox curWindowBox = {wX, wY, wW, wH};
                     g_pHyprOpenGL->m_renderData.clipBox = curWorkspaceBox;
-
-                    // For focused windows, choose rendering method based on config
-                    if (w == g_pCompositor->m_lastWindow.lock()) {
-                        if (Config::showFocusedWindowContent) {
-                            // Try to show actual window content (experimental)
-                            renderFocusedWindowStub(w, owner, owner->m_activeWorkspace, curWindowBox, &time);
-                        } else if (Config::enableFocusedWindowPlaceholder) {
-                            // Use placeholder rendering (safe default)
-                            CHyprColor placeholderColor = Config::focusedWindowPlaceholderColor;
-                            CHyprColor borderColor = Config::focusedWindowPlaceholderBorderColor;
-
-                            if (!Config::disableBlur) {
-                                renderRectWithBlur(curWindowBox, placeholderColor);
-                            } else {
-                                renderRect(curWindowBox, placeholderColor);
-                            }
-
-                            // Add a border to indicate it's the focused window
-                            if (Config::workspaceBorderSize > 0) {
-                                renderBorder(curWindowBox, CGradientValueData(borderColor), Config::workspaceBorderSize);
-                            }
-                        }
-                    } else {
-                        //g_pHyprOpenGL->renderRectWithBlur(&curWindowBox, CHyprColor(0, 0, 0, 0));
-                        renderWindowStub(w, owner, owner->m_activeWorkspace, curWindowBox, &time);
-                    }
+                    //g_pHyprOpenGL->renderRectWithBlur(&curWindowBox, CHyprColor(0, 0, 0, 0));
+                    renderWindowStub(w, owner, curWindowBox, &time);
                     g_pHyprOpenGL->m_renderData.clipBox = CBox();
                 }
             }
@@ -460,40 +429,23 @@ void CHyprspaceWidget::draw() {
             if (ws->getLastFocusedWindow())
                 if (ws->getLastFocusedWindow()->m_isFloating) {
                     const auto w = ws->getLastFocusedWindow();
+                    // Skip invalid windows or windows without proper state
+                    if (!w->m_isMapped || w->isHidden()) {
+                        // Continue to next workspace instead of breaking the loop
+                        curWorkspaceRectOffsetX += workspaceBoxW + Config::workspaceMargin * owner->m_scale;
+                        continue;
+                    }
                     double wX = curWorkspaceRectOffsetX + ((w->m_realPosition->value().x - owner->m_position.x) * monitorSizeScaleFactor * owner->m_scale);
                     double wY = curWorkspaceRectOffsetY + ((w->m_realPosition->value().y - owner->m_position.y) * monitorSizeScaleFactor * owner->m_scale);
                     double wW = w->m_realSize->value().x * monitorSizeScaleFactor * owner->m_scale;
                     double wH = w->m_realSize->value().y * monitorSizeScaleFactor * owner->m_scale;
-                    if (!(wW > 0 && wH > 0)) continue;
-                    CBox curWindowBox = {wX, wY, wW, wH};
-                    g_pHyprOpenGL->m_renderData.clipBox = curWorkspaceBox;
-
-                    // For focused windows, choose rendering method based on config
-                    if (w == g_pCompositor->m_lastWindow.lock()) {
-                        if (Config::showFocusedWindowContent) {
-                            // Try to show actual window content (experimental)
-                            renderFocusedWindowStub(w, owner, owner->m_activeWorkspace, curWindowBox, &time);
-                        } else if (Config::enableFocusedWindowPlaceholder) {
-                            // Use placeholder rendering (safe default)
-                            CHyprColor placeholderColor = Config::focusedWindowPlaceholderColor;
-                            CHyprColor borderColor = Config::focusedWindowPlaceholderBorderColor;
-
-                            if (!Config::disableBlur) {
-                                renderRectWithBlur(curWindowBox, placeholderColor);
-                            } else {
-                                renderRect(curWindowBox, placeholderColor);
-                            }
-
-                            // Add a border to indicate it's the focused window
-                            if (Config::workspaceBorderSize > 0) {
-                                renderBorder(curWindowBox, CGradientValueData(borderColor), Config::workspaceBorderSize);
-                            }
-                        }
-                    } else {
+                    if (wW > 0 && wH > 0) {
+                        CBox curWindowBox = {wX, wY, wW, wH};
+                        g_pHyprOpenGL->m_renderData.clipBox = curWorkspaceBox;
                         //g_pHyprOpenGL->renderRectWithBlur(&curWindowBox, CHyprColor(0, 0, 0, 0));
-                        renderWindowStub(w, owner, owner->m_activeWorkspace, curWindowBox, &time);
+                        renderWindowStub(w, owner, curWindowBox, &time);
+                        g_pHyprOpenGL->m_renderData.clipBox = CBox();
                     }
-                    g_pHyprOpenGL->m_renderData.clipBox = CBox();
                 }
         }
 
diff --git a/src/main.cpp b/src/main.cpp
index b2f35af..91e5ab4 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -52,21 +52,17 @@ bool Config::reverseSwipe = false;
 bool Config::disableBlur = false;
 
 float Config::overrideAnimSpeed = 0;
-
 bool Config::enableFocusedWindowPlaceholder = true;
 CHyprColor Config::focusedWindowPlaceholderColor = CHyprColor(0.3f, 0.3f, 0.3f, 0.5f);
 CHyprColor Config::focusedWindowPlaceholderBorderColor = CHyprColor(0.8f, 0.8f, 0.8f, 0.8f);
 float Config::focusedWindowPlaceholderAlpha = 0.5;
 
 bool Config::showFocusedWindowContent = false;
-
 float Config::dragAlpha = 0.2;
 
-
 // Texture capture system globals
 std::unordered_map<PHLWINDOW, CachedWindowTexture> g_windowTextureCache;
 bool g_enableTextureCapture = false;
-
 int numWorkspaces = -1; //hyprsplit/split-monitor-workspaces support
 
 Hyprutils::Memory::CSharedPointer<HOOK_CALLBACK_FN> g_pRenderHook;
@@ -154,11 +150,9 @@ void onRender(void* thisptr, SCallbackInfo& info, std::any args) {
                 if (g_oAlpha != -1) {
                     if (const auto curWindow = g_pInputManager->m_currentlyDraggedWindow.lock()) {
                         curWindow->m_activeInactiveAlpha->setValueAndWarp(Config::dragAlpha);
-                        curWindow->m_windowData.noBlur = CWindowOverridableVar<bool>(true, eOverridePriority::PRIORITY_SET_PROP);
                         timespec time;
                         clock_gettime(CLOCK_MONOTONIC, &time);
                         (*(tRenderWindow)pRenderWindow)(g_pHyprRenderer.get(), curWindow, widget->getOwner(), &time, true, RENDER_PASS_MAIN, false, false);
-                        curWindow->m_windowData.noBlur.unset(eOverridePriority::PRIORITY_SET_PROP);
                         curWindow->m_activeInactiveAlpha->setValueAndWarp(g_oAlpha);
                     }
                 }
@@ -441,7 +435,7 @@ void reloadConfig() {
     Config::disableBlur = std::any_cast<Hyprlang::INT>(HyprlandAPI::getConfigValue(pHandle, "plugin:overview:disableBlur")->getValue());
 
     Config::overrideAnimSpeed = std::any_cast<Hyprlang::FLOAT>(HyprlandAPI::getConfigValue(pHandle, "plugin:overview:overrideAnimSpeed")->getValue());
-
+    
     // We don't need to store exitKey in Config namespace as it's only used in onKeyPress
 
     for (auto& widget : g_overviewWidgets) {
@@ -524,9 +518,9 @@ APICALL EXPORT PLUGIN_DESCRIPTION_INFO PLUGIN_INIT(HANDLE inHandle) {
     g_pConfigReloadHook = HyprlandAPI::registerCallbackDynamic(pHandle, "configReloaded", [&] (void* thisptr, SCallbackInfo& info, std::any data) { reloadConfig(); });
     HyprlandAPI::reloadConfig();
 
-    HyprlandAPI::addDispatcher(pHandle, "overview:toggle", ::dispatchToggleOverview);
-    HyprlandAPI::addDispatcher(pHandle, "overview:open", ::dispatchOpenOverview);
-    HyprlandAPI::addDispatcher(pHandle, "overview:close", ::dispatchCloseOverview);
+    HyprlandAPI::addDispatcherV2(pHandle, "overview:toggle", ::dispatchToggleOverview);
+    HyprlandAPI::addDispatcherV2(pHandle, "overview:open", ::dispatchOpenOverview);
+    HyprlandAPI::addDispatcherV2(pHandle, "overview:close", ::dispatchCloseOverview);
 
     g_pRenderHook = HyprlandAPI::registerCallbackDynamic(pHandle, "render", onRender);
 
